# آزمایش ششم - آزمایشگاه مهندسی نرم‌افزار
اعضای گروه: امیرحسین ندایی پور، علی مهربانی

## گزارش مراحل انجام آزمایش

در این بخش هفت مورد بازآرایی خواسته شده را خواهیم داشت:

### بازآرایی اول

### بازآرایی دوم

### بازآرایی سوم

### بازآرایی چهارم

در این بازآرایی که از نوع Separate Query From Modifier است در کلاس Memory.java تابع getTemp که دو عمل افزایش متغیر و بازگرداندن آن را انجام می‌دهد را به دو تابع getTemp و incTemp می‌شکنیم و همچنین در تمامی نقاطی از کد که از این تابع استفاده شده است، دو تابع جدید را جایگزین می‌کنیم. در تصویر زیر کد تغییر یافته و تابع اضافه شده را مشاهده می‌کنیم:

![image](https://github.com/AliMehrabani/SEL-Week6/assets/59169318/22dcd346-401b-4cb2-bc3a-3a078f797ed7)


### بازآرایی پنجم

در این بازآرایی که از نوع Extract Variable است در کلاس CodeGenerator.java یکی از شرط‌هایی به نسبت طول بلندی دارد را به صورت متغیرهای کوچک می‌نویسیم و در نهایت متغیرها را که هر کدام مشخص می‌کنند چه شرطی بررسی شده است را درون if اصلی قرار می‌دهیم. این بازآرایی را در تصویر زیر مشاهده می‌کنید:

![image](https://github.com/AliMehrabani/SEL-Week6/assets/59169318/408676c2-6f29-479e-9688-53da62ecef18)


### بازآرایی ششم

در این بازآرایی که از نوع Self Encapsulate Field است برای متغیر tempSize که private است یک تابع getter ایجاد می‌کنیم و از این به بعد درون کلاس برای دسترسی به آن از این تابع استفاده می‌کنیم. در تصویر زیر کد تغییر داده شده را می‌بینید:

![image](https://github.com/AliMehrabani/SEL-Week6/assets/59169318/ba063819-ce9e-412f-9be6-a9c2c3a13900)


### بازآرایی هفتم

در این بازآرایی که از نوع Encapsulate Field است متغیر address در کلاس Symbol.java را به حالت private تغییر داده و برای آن یک getter ایجاد می‌کنیم. در تصویر زیر تغییر ایجاد شده را مشاهده می‌کنیم. همچنین موارد استفاده از این متغیر را هم مطابق با این تغییر اصلاح می‌کنیم:

![image](https://github.com/AliMehrabani/SEL-Week6/assets/59169318/4dba4949-6ab6-4519-8150-04f5989b8560)


## پاسخ پرسش‌ها

### پرسش 1

### پرسش 2

### پرسش 3

مطابق توضیحات سایت refactoring.guru، بوی بد Lazy class در دسته‌ی Dispensables قرار می‌گیرد که نشان دهنده بخشی از کد است که نبود آن به فهم و تمیزی کد کمک می‌کند. برای حذف کلاس‌های بی مورد می‌توان از Inline Class Refactoring استفاده کرد. همچنین وقتی یک زیرکلاس کاربرد خاصی نداشته باشد می‌توان از Collapse Hierarchy Refactoring استفاده کرد. درنهایت اگر وجود همچین کلاس‌هایی برای توسعه نرم‌افزار در آینده در نظرگرفته شده باشد می‌توان از حذف آن‌ها صرف نظر کرد.
